// Code generated by goagen v1.4.0, DO NOT EDIT.
//
// API "my-inventory": genres Resource Client
//
// Command:
// $ goagen
// --design=github.com/NBR41/go-testgoa/design
// --out=$(GOPATH)/src/github.com/NBR41/go-testgoa
// --version=v1.3.1

package client

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
)

// CreateGenresPayload is the genres create action payload.
type CreateGenresPayload struct {
	// Genre Name (Shonen/Shojo/Seinen)
	GenreName string `form:"genre_name" json:"genre_name" yaml:"genre_name" xml:"genre_name"`
}

// CreateGenresPath computes a request path to the create action of genres.
func CreateGenresPath() string {

	return fmt.Sprintf("/genres")
}

// Create new genre
func (c *Client) CreateGenres(ctx context.Context, path string, payload *CreateGenresPayload, contentType string) (*http.Response, error) {
	req, err := c.NewCreateGenresRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewCreateGenresRequest create the request corresponding to the create action endpoint of the genres resource.
func (c *Client) NewCreateGenresRequest(ctx context.Context, path string, payload *CreateGenresPayload, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	if c.JWTSecSigner != nil {
		if err := c.JWTSecSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// DeleteGenresPath computes a request path to the delete action of genres.
func DeleteGenresPath(genreID int) string {
	param0 := strconv.Itoa(genreID)

	return fmt.Sprintf("/genres/%s", param0)
}

// delete genre by id
func (c *Client) DeleteGenres(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewDeleteGenresRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewDeleteGenresRequest create the request corresponding to the delete action endpoint of the genres resource.
func (c *Client) NewDeleteGenresRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSecSigner != nil {
		if err := c.JWTSecSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// ListGenresPath computes a request path to the list action of genres.
func ListGenresPath() string {

	return fmt.Sprintf("/genres")
}

// Get genres
func (c *Client) ListGenres(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewListGenresRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewListGenresRequest create the request corresponding to the list action endpoint of the genres resource.
func (c *Client) NewListGenresRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ShowGenresPath computes a request path to the show action of genres.
func ShowGenresPath(genreID int) string {
	param0 := strconv.Itoa(genreID)

	return fmt.Sprintf("/genres/%s", param0)
}

// Get genre by id
func (c *Client) ShowGenres(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewShowGenresRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewShowGenresRequest create the request corresponding to the show action endpoint of the genres resource.
func (c *Client) NewShowGenresRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// UpdateGenresPayload is the genres update action payload.
type UpdateGenresPayload struct {
	// Genre Name (Shonen/Shojo/Seinen)
	GenreName string `form:"genre_name" json:"genre_name" yaml:"genre_name" xml:"genre_name"`
}

// UpdateGenresPath computes a request path to the update action of genres.
func UpdateGenresPath(genreID int) string {
	param0 := strconv.Itoa(genreID)

	return fmt.Sprintf("/genres/%s", param0)
}

// Update genre by id
func (c *Client) UpdateGenres(ctx context.Context, path string, payload *UpdateGenresPayload, contentType string) (*http.Response, error) {
	req, err := c.NewUpdateGenresRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewUpdateGenresRequest create the request corresponding to the update action endpoint of the genres resource.
func (c *Client) NewUpdateGenresRequest(ctx context.Context, path string, payload *UpdateGenresPayload, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	if c.JWTSecSigner != nil {
		if err := c.JWTSecSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}
